# F1.3: macOS Desktop Core

**Feature ID:** F1.3
**Priority:** P0 (MVP)
**Status:** Not Started
**Package:** `packages/desktop-mac`

---

## Overview

Build a native macOS desktop application that provides system-wide grammar checking using Accessibility APIs. The app runs as a menu bar utility with a floating editor window, enabling grammar checking in any application.

### Goals

1. Menu bar presence with status and quick actions
2. System-wide text extraction via Accessibility API
3. Floating editor window for dedicated writing
4. Global keyboard shortcut to trigger checks
5. Local LanguageTool server management
6. Local LLM inference via llama.cpp

### Non-Goals

- MS Office integration (separate add-in, P1)
- iOS companion app (P2)
- Cloud sync (P1)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────┐
│                    WriteForge macOS App                           │
├──────────────────────────────────────────────────────────────────┤
│                                                                    │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │                      App Layer (SwiftUI)                     │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │  │
│  │  │  MenuBarView │  │ FloatingEdit │  │  PreferencesView │  │  │
│  │  │  - Status    │  │ - Editor     │  │  - Settings      │  │  │
│  │  │  - Actions   │  │ - Suggest.   │  │  - Dictionary    │  │  │
│  │  └──────┬───────┘  └──────┬───────┘  └────────┬─────────┘  │  │
│  └─────────┼─────────────────┼───────────────────┼─────────────┘  │
│            │                 │                   │                 │
│  ┌─────────┼─────────────────┼───────────────────┼─────────────┐  │
│  │         ▼                 ▼                   ▼              │  │
│  │                    Service Layer                             │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │  │
│  │  │ Accessibility│  │ GrammarSvc   │  │    LLMService    │  │  │
│  │  │ Service      │  │ (LT client)  │  │   (llama.cpp)    │  │  │
│  │  │ - AXUIElement│  │              │  │                  │  │  │
│  │  │ - Text extr. │  │              │  │                  │  │  │
│  │  └──────────────┘  └──────────────┘  └──────────────────┘  │  │
│  │                                                              │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │  │
│  │  │ HotkeyService│  │ DictionarySvc│  │ LTServerManager  │  │  │
│  │  │ - Global key │  │ - Add/remove │  │ - Start/stop     │  │  │
│  │  │ - Cmd+Shift+G│  │ - SQLite     │  │ - Health check   │  │  │
│  │  └──────────────┘  └──────────────┘  └──────────────────┘  │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                    │
└──────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────┐
│                       Local Services                              │
│  ┌─────────────────────┐  ┌─────────────────────────────────┐   │
│  │  LanguageTool JAR   │  │  Qwen2.5-1.5B Model (GGUF)      │   │
│  │  (Embedded server)  │  │  ~/Library/Application Support/  │   │
│  │  Port 8010          │  │  WriteForge/models/              │   │
│  └─────────────────────┘  └─────────────────────────────────┘   │
└──────────────────────────────────────────────────────────────────┘
```

---

## Data Models

### AppState

```swift
@Observable
class AppState {
    var isEnabled: Bool = true
    var ltServerStatus: ServerStatus = .starting
    var llmModelStatus: ModelStatus = .notLoaded
    var currentIssues: [GrammarIssue] = []
    var selectedLanguage: String = "en-US"
    var isFloatingWindowVisible: Bool = false
}

enum ServerStatus {
    case starting
    case running
    case stopped
    case error(String)
}

enum ModelStatus {
    case notLoaded
    case downloading(progress: Double)
    case loading
    case ready
    case error(String)
}
```

### GrammarIssue

```swift
struct GrammarIssue: Identifiable, Codable {
    let id: UUID
    let type: IssueType
    let ruleId: String
    let message: String
    let shortMessage: String
    let offset: Int
    let length: Int
    let context: String
    let replacements: [String]
    let severity: Severity

    enum IssueType: String, Codable {
        case grammar
        case spelling
        case punctuation
        case style
        case typography
    }

    enum Severity: String, Codable {
        case error
        case warning
        case info
    }
}
```

---

## Component Design

### App Entry Point

```swift
// WriteForge/App/WriteForgeApp.swift

import SwiftUI

@main
struct WriteForgeApp: App {
    @StateObject private var appState = AppState()
    @StateObject private var services = ServiceContainer()

    var body: some Scene {
        // Menu bar presence
        MenuBarExtra {
            MenuBarView()
                .environmentObject(appState)
                .environmentObject(services)
        } label: {
            Image(systemName: appState.isEnabled ? "text.badge.checkmark" : "text.badge.xmark")
        }
        .menuBarExtraStyle(.window)

        // Floating editor window
        Window("WriteForge Editor", id: "editor") {
            FloatingEditorView()
                .environmentObject(appState)
                .environmentObject(services)
        }
        .windowStyle(.hiddenTitleBar)
        .windowResizability(.contentSize)
        .defaultPosition(.topTrailing)

        // Preferences window
        Settings {
            PreferencesView()
                .environmentObject(appState)
                .environmentObject(services)
        }
    }

    init() {
        // Register global hotkey
        HotkeyService.shared.register(.init(key: .g, modifiers: [.command, .shift])) {
            NotificationCenter.default.post(name: .triggerGrammarCheck, object: nil)
        }
    }
}
```

### Menu Bar View

```swift
// WriteForge/Views/MenuBarView.swift

import SwiftUI

struct MenuBarView: View {
    @EnvironmentObject var appState: AppState
    @EnvironmentObject var services: ServiceContainer

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Status section
            HStack {
                StatusIndicator(status: appState.ltServerStatus)
                Text(statusText)
                    .font(.headline)
            }

            Divider()

            // Quick actions
            if !appState.currentIssues.isEmpty {
                Text("\(appState.currentIssues.count) issues found")
                    .font(.subheadline)
                    .foregroundColor(.secondary)

                Button("Show Issues") {
                    openFloatingWindow()
                }
            }

            Toggle("Enable WriteForge", isOn: $appState.isEnabled)

            Divider()

            Button("Open Editor") {
                openFloatingWindow()
            }
            .keyboardShortcut("g", modifiers: [.command, .shift])

            Button("Check Clipboard") {
                checkClipboard()
            }

            Divider()

            Button("Preferences...") {
                openPreferences()
            }
            .keyboardShortcut(",", modifiers: .command)

            Button("Quit WriteForge") {
                NSApplication.shared.terminate(nil)
            }
            .keyboardShortcut("q", modifiers: .command)
        }
        .padding()
        .frame(width: 280)
    }

    private var statusText: String {
        switch appState.ltServerStatus {
        case .running: return "Ready"
        case .starting: return "Starting..."
        case .stopped: return "Disabled"
        case .error(let msg): return "Error: \(msg)"
        }
    }
}
```

### Accessibility Service

```swift
// WriteForge/Services/AccessibilityService.swift

import AppKit
import ApplicationServices

final class AccessibilityService {
    private let logger = Logger(subsystem: "com.writeforge.app", category: "accessibility")

    /// Check if accessibility permissions are granted
    var hasPermission: Bool {
        AXIsProcessTrusted()
    }

    /// Request accessibility permissions
    func requestPermission() {
        let options = [kAXTrustedCheckOptionPrompt.takeUnretainedValue(): true] as CFDictionary
        AXIsProcessTrustedWithOptions(options)
    }

    /// Get focused text element from frontmost application
    func getFocusedTextElement() -> AXUIElement? {
        guard hasPermission else {
            logger.warning("Accessibility permission not granted")
            return nil
        }

        let systemWide = AXUIElementCreateSystemWide()

        var focusedApp: CFTypeRef?
        let appResult = AXUIElementCopyAttributeValue(
            systemWide,
            kAXFocusedApplicationAttribute as CFString,
            &focusedApp
        )

        guard appResult == .success, let app = focusedApp else {
            logger.debug("No focused application")
            return nil
        }

        var focusedElement: CFTypeRef?
        let elementResult = AXUIElementCopyAttributeValue(
            app as! AXUIElement,
            kAXFocusedUIElementAttribute as CFString,
            &focusedElement
        )

        guard elementResult == .success, let element = focusedElement else {
            logger.debug("No focused element")
            return nil
        }

        return element as! AXUIElement
    }

    /// Extract text from focused element
    func getSelectedText() -> String? {
        guard let element = getFocusedTextElement() else { return nil }

        var selectedText: CFTypeRef?
        let result = AXUIElementCopyAttributeValue(
            element,
            kAXSelectedTextAttribute as CFString,
            &selectedText
        )

        if result == .success, let text = selectedText as? String, !text.isEmpty {
            return text
        }

        // Fall back to full text value
        var fullText: CFTypeRef?
        let fullResult = AXUIElementCopyAttributeValue(
            element,
            kAXValueAttribute as CFString,
            &fullText
        )

        return fullResult == .success ? fullText as? String : nil
    }

    /// Replace selected text with new text
    func replaceSelectedText(with newText: String) -> Bool {
        guard let element = getFocusedTextElement() else { return false }

        let result = AXUIElementSetAttributeValue(
            element,
            kAXSelectedTextAttribute as CFString,
            newText as CFTypeRef
        )

        return result == .success
    }
}
```

### Grammar Service

```swift
// WriteForge/Services/GrammarService.swift

import Foundation
import os.log

final class GrammarService {
    private let logger = Logger(subsystem: "com.writeforge.app", category: "grammar")
    private let baseURL: URL
    private let session: URLSession

    init(baseURL: URL = URL(string: "http://localhost:8010")!) {
        self.baseURL = baseURL

        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 5
        self.session = URLSession(configuration: config)
    }

    /// Check text for grammar issues
    func check(text: String, language: String = "en-US") async throws -> [GrammarIssue] {
        logger.debug("Checking text of length \(text.count)")

        guard !text.isEmpty else { return [] }

        var components = URLComponents(url: baseURL.appendingPathComponent("v2/check"), resolvingAgainstBaseURL: false)!

        var request = URLRequest(url: components.url!)
        request.httpMethod = "POST"
        request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")

        let body = "text=\(text.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "")&language=\(language)"
        request.httpBody = body.data(using: .utf8)

        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            throw GrammarError.serverError
        }

        let ltResponse = try JSONDecoder().decode(LanguageToolResponse.self, from: data)

        return ltResponse.matches.map { match in
            GrammarIssue(
                id: UUID(),
                type: classifyType(match),
                ruleId: match.rule.id,
                message: match.message,
                shortMessage: match.shortMessage ?? match.message,
                offset: match.offset,
                length: match.length,
                context: match.context.text,
                replacements: match.replacements.prefix(5).map(\.value),
                severity: classifySeverity(match)
            )
        }
    }

    /// Check if server is running
    func healthCheck() async -> Bool {
        do {
            let url = baseURL.appendingPathComponent("v2/languages")
            let (_, response) = try await session.data(from: url)
            return (response as? HTTPURLResponse)?.statusCode == 200
        } catch {
            return false
        }
    }

    private func classifyType(_ match: LTMatch) -> GrammarIssue.IssueType {
        switch match.rule.category.id {
        case "TYPOS": return .spelling
        case "GRAMMAR": return .grammar
        case "PUNCTUATION": return .punctuation
        case "STYLE", "REDUNDANCY": return .style
        case "TYPOGRAPHY": return .typography
        default: return .grammar
        }
    }

    private func classifySeverity(_ match: LTMatch) -> GrammarIssue.Severity {
        if match.rule.category.id == "TYPOS" { return .error }
        if match.rule.category.id == "STYLE" { return .info }
        return .warning
    }
}

enum GrammarError: Error {
    case serverError
    case networkError
    case parseError
}
```

### LLM Service

```swift
// WriteForge/Services/LLMService.swift

import Foundation
import os.log

final class LLMService {
    private let logger = Logger(subsystem: "com.writeforge.app", category: "llm")
    private var llamaContext: OpaquePointer?
    private let modelPath: URL
    private var isLoaded = false

    init() {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        self.modelPath = appSupport
            .appendingPathComponent("WriteForge")
            .appendingPathComponent("models")
            .appendingPathComponent("qwen2.5-1.5b-instruct-q4_k_m.gguf")
    }

    /// Load the LLM model
    func loadModel() async throws {
        guard !isLoaded else { return }

        logger.info("Loading LLM model from \(self.modelPath.path)")

        guard FileManager.default.fileExists(atPath: modelPath.path) else {
            throw LLMError.modelNotFound
        }

        // llama.cpp initialization
        // This would use Swift bindings to llama.cpp
        // Simplified for documentation

        isLoaded = true
        logger.info("LLM model loaded successfully")
    }

    /// Generate AI suggestion for text
    func getSuggestion(text: String, context: SuggestionContext) async throws -> String {
        guard isLoaded else {
            throw LLMError.modelNotLoaded
        }

        let prompt = buildPrompt(text: text, context: context)

        // Generate using llama.cpp
        // Returns suggestion text

        return "" // Placeholder
    }

    /// Detect tone of text
    func detectTone(text: String) async throws -> Tone {
        guard isLoaded else {
            throw LLMError.modelNotLoaded
        }

        // Use LLM to classify tone
        return .neutral
    }

    private func buildPrompt(text: String, context: SuggestionContext) -> String {
        switch context {
        case .grammar:
            return """
            Fix any grammar errors in the following text. Only output the corrected text, nothing else.

            Text: \(text)
            """
        case .rewrite(let tone):
            return """
            Rewrite the following text in a \(tone.rawValue) tone. Only output the rewritten text, nothing else.

            Text: \(text)
            """
        case .shorten:
            return """
            Make the following text more concise while preserving meaning. Only output the shortened text, nothing else.

            Text: \(text)
            """
        }
    }
}

enum LLMError: Error {
    case modelNotFound
    case modelNotLoaded
    case generationFailed
}

enum SuggestionContext {
    case grammar
    case rewrite(tone: Tone)
    case shorten
}

enum Tone: String {
    case formal
    case casual
    case confident
    case friendly
    case neutral
}
```

### LanguageTool Server Manager

```swift
// WriteForge/Services/LTServerManager.swift

import Foundation
import os.log

final class LTServerManager {
    private let logger = Logger(subsystem: "com.writeforge.app", category: "ltserver")
    private var process: Process?
    private let jarPath: URL
    private let port: Int = 8010

    init() {
        // JAR bundled in app resources
        self.jarPath = Bundle.main.url(forResource: "languagetool-server", withExtension: "jar")!
    }

    /// Start the LanguageTool server
    func start() async throws {
        guard process == nil else {
            logger.debug("Server already running")
            return
        }

        logger.info("Starting LanguageTool server on port \(self.port)")

        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/java")
        process.arguments = [
            "-Xms512m",
            "-Xmx2g",
            "-jar", jarPath.path,
            "--port", String(port),
            "--allow-origin", "*"
        ]

        // Capture output for debugging
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = pipe

        try process.run()
        self.process = process

        // Wait for server to be ready
        try await waitForReady()

        logger.info("LanguageTool server started successfully")
    }

    /// Stop the LanguageTool server
    func stop() {
        guard let process = process, process.isRunning else { return }

        logger.info("Stopping LanguageTool server")
        process.terminate()
        self.process = nil
    }

    /// Check if server is ready
    private func waitForReady(timeout: TimeInterval = 30) async throws {
        let deadline = Date().addingTimeInterval(timeout)

        while Date() < deadline {
            if await isReady() {
                return
            }
            try await Task.sleep(nanoseconds: 500_000_000) // 0.5s
        }

        throw LTServerError.startupTimeout
    }

    private func isReady() async -> Bool {
        do {
            let url = URL(string: "http://localhost:\(port)/v2/languages")!
            let (_, response) = try await URLSession.shared.data(from: url)
            return (response as? HTTPURLResponse)?.statusCode == 200
        } catch {
            return false
        }
    }
}

enum LTServerError: Error {
    case startupTimeout
    case javaNotFound
}
```

---

## File Structure

```
packages/desktop-mac/
├── WriteForge/
│   ├── App/
│   │   ├── WriteForgeApp.swift       # App entry point
│   │   └── ServiceContainer.swift    # DI container
│   ├── Views/
│   │   ├── MenuBarView.swift         # Menu bar UI
│   │   ├── FloatingEditorView.swift  # Floating window
│   │   ├── PreferencesView.swift     # Settings
│   │   ├── Components/
│   │   │   ├── StatusIndicator.swift
│   │   │   ├── IssueCard.swift
│   │   │   └── SuggestionList.swift
│   │   └── Styles/
│   │       └── AppStyles.swift
│   ├── Services/
│   │   ├── AccessibilityService.swift
│   │   ├── GrammarService.swift
│   │   ├── LLMService.swift
│   │   ├── LTServerManager.swift
│   │   ├── HotkeyService.swift
│   │   └── DictionaryService.swift
│   ├── Models/
│   │   ├── AppState.swift
│   │   ├── GrammarIssue.swift
│   │   └── Settings.swift
│   ├── Resources/
│   │   ├── Assets.xcassets
│   │   ├── languagetool-server.jar
│   │   └── Localizable.strings
│   └── Supporting/
│       ├── Info.plist
│       └── WriteForge.entitlements
├── WriteForge.xcodeproj/
├── WriteForgeTests/
│   ├── GrammarServiceTests.swift
│   ├── AccessibilityServiceTests.swift
│   └── LLMServiceTests.swift
└── README.md
```

---

## Permissions Required

### Info.plist Entries

```xml
<key>NSAccessibilityUsageDescription</key>
<string>WriteForge needs accessibility access to check text in other applications.</string>

<key>NSAppleEventsUsageDescription</key>
<string>WriteForge needs to interact with other applications for grammar checking.</string>
```

### Entitlements

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.app-sandbox</key>
    <false/>
    <key>com.apple.security.automation.apple-events</key>
    <true/>
    <key>com.apple.security.temporary-exception.apple-events</key>
    <array>
        <string>com.apple.systemevents</string>
    </array>
</dict>
</plist>
```

**Note:** Sandbox disabled for Accessibility API access. Consider hardened runtime for notarization.

---

## Testing Strategy

### Unit Tests

```swift
final class GrammarServiceTests: XCTestCase {
    var service: GrammarService!

    override func setUp() {
        service = GrammarService()
    }

    func testCheckReturnsIssuesForBadGrammar() async throws {
        let issues = try await service.check(text: "This are a test.")

        XCTAssertFalse(issues.isEmpty)
        XCTAssertTrue(issues.contains { $0.type == .grammar })
    }

    func testCheckReturnsEmptyForCorrectText() async throws {
        let issues = try await service.check(text: "This is a test.")

        XCTAssertTrue(issues.isEmpty)
    }

    func testHealthCheckWhenServerRunning() async {
        let healthy = await service.healthCheck()
        XCTAssertTrue(healthy)
    }
}
```

### UI Tests

```swift
final class WriteForgeUITests: XCTestCase {
    var app: XCUIApplication!

    override func setUp() {
        app = XCUIApplication()
        app.launch()
    }

    func testMenuBarPresence() {
        let menuBar = app.menuBars.firstMatch
        XCTAssertTrue(menuBar.exists)
    }

    func testFloatingEditorOpens() {
        // Click menu bar icon
        app.menuBarItems["WriteForge"].click()

        // Click Open Editor
        app.menuItems["Open Editor"].click()

        // Verify editor window
        XCTAssertTrue(app.windows["WriteForge Editor"].exists)
    }
}
```

---

## Acceptance Criteria

- [ ] App appears in menu bar with status icon
- [ ] Menu bar dropdown shows server status
- [ ] Floating editor window opens via menu or Cmd+Shift+G
- [ ] Accessibility permission requested on first launch
- [ ] Text extracted from focused application
- [ ] Grammar issues displayed in floating editor
- [ ] Suggestions can be accepted (replaces text)
- [ ] LanguageTool server starts automatically
- [ ] LLM model loads on demand
- [ ] Works offline (local LT + local LLM)
- [ ] 70% test coverage

---

**Document Version:** 1.0.0
**Created:** January 2026
**Author:** AI Assistant
