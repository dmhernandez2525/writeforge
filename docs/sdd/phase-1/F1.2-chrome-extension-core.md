# F1.2: Chrome Extension Core

**Feature ID:** F1.2
**Priority:** P0 (MVP)
**Status:** Not Started
**Package:** `@writeforge/extension`

---

## Overview

Build a Chrome extension that provides real-time grammar checking for web content. The extension monitors text input in textareas, contenteditable elements, and specific sites (Google Docs, Gmail) while rendering inline suggestions.

### Goals

1. Monitor and check text in textareas and contenteditable elements
2. Integrate with Google Docs and Gmail compose
3. Render visual underlines for issues (red/blue/yellow)
4. Display suggestion cards with accept/dismiss actions
5. Work 100% offline using local LanguageTool and LLM

### Non-Goals

- Safari/Firefox support (handled by F2.1, F2.2)
- Full document analysis dashboard (handled by F2.14)
- MS Office integration (handled by desktop apps)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────┐
│                        Chrome Extension                           │
├──────────────────────────────────────────────────────────────────┤
│                                                                    │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │                    Background Worker                         │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌──────────────────┐    │  │
│  │  │ GrammarSvc  │  │   LLMSvc    │  │  DictionarySvc   │    │  │
│  │  │ (LT client) │  │  (WebLLM)   │  │ (storage.local)  │    │  │
│  │  └──────┬──────┘  └──────┬──────┘  └────────┬─────────┘    │  │
│  │         └────────────────┼──────────────────┘               │  │
│  │                          ▼                                   │  │
│  │              ┌──────────────────────┐                       │  │
│  │              │  Message Handler      │                       │  │
│  │              │  - CHECK_TEXT        │                       │  │
│  │              │  - GET_SUGGESTIONS   │                       │  │
│  │              │  - ADD_TO_DICTIONARY │                       │  │
│  │              └──────────┬───────────┘                       │  │
│  └─────────────────────────┼───────────────────────────────────┘  │
│                            │ chrome.runtime.sendMessage           │
│  ┌─────────────────────────┼───────────────────────────────────┐  │
│  │                  Content Script                              │  │
│  │                         ▼                                    │  │
│  │  ┌──────────────────────────────────────────────────────┐   │  │
│  │  │              Text Field Monitor                       │   │  │
│  │  │  - MutationObserver (contenteditable)                │   │  │
│  │  │  - Input event listener (textarea)                    │   │  │
│  │  │  - Debounced check triggering                        │   │  │
│  │  └───────────────────────┬──────────────────────────────┘   │  │
│  │                          ▼                                   │  │
│  │  ┌──────────────────────────────────────────────────────┐   │  │
│  │  │              Suggestion Renderer                      │   │  │
│  │  │  - Shadow DOM for isolation                          │   │  │
│  │  │  - Underline positioning                             │   │  │
│  │  │  - Suggestion card popups                            │   │  │
│  │  └──────────────────────────────────────────────────────┘   │  │
│  └─────────────────────────────────────────────────────────────┘  │
│                                                                    │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │  Popup                    │  Options Page                   │  │
│  │  - Status display         │  - Language selection           │  │
│  │  - Quick toggle           │  - Disabled sites               │  │
│  │  - Issue summary          │  - Dictionary management        │  │
│  └─────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────┐
│                    Local Services                                 │
│  ┌────────────────────┐  ┌────────────────────────────────────┐  │
│  │  LanguageTool      │  │  WebLLM (Qwen2.5-0.5B)              │  │
│  │  localhost:8010    │  │  IndexedDB model cache              │  │
│  └────────────────────┘  └────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────┘
```

---

## Data Models

### TextFieldState

```typescript
interface TextFieldState {
  /** Unique identifier for this text field */
  id: string;

  /** The DOM element being monitored */
  element: HTMLElement;

  /** Current text content */
  text: string;

  /** Current cursor position */
  cursorPosition: number;

  /** Active issues for this field */
  issues: RenderedIssue[];

  /** Last check timestamp */
  lastChecked: number;

  /** Is checking currently in progress */
  checking: boolean;
}
```

### RenderedIssue

```typescript
interface RenderedIssue {
  /** Issue from GrammarService */
  issue: GrammarIssue;

  /** DOM range for the issue */
  range: Range;

  /** Underline element */
  underlineElement: HTMLElement;

  /** Whether suggestion card is visible */
  cardVisible: boolean;

  /** User's decision */
  status: 'pending' | 'accepted' | 'dismissed' | 'ignored';
}
```

### ExtensionMessage

```typescript
type ExtensionMessage =
  | { type: 'CHECK_TEXT'; text: string; language: string }
  | { type: 'GET_AI_SUGGESTION'; text: string; context: string }
  | { type: 'ADD_TO_DICTIONARY'; word: string }
  | { type: 'REMOVE_FROM_DICTIONARY'; word: string }
  | { type: 'GET_SETTINGS' }
  | { type: 'UPDATE_SETTINGS'; settings: Partial<Settings> };
```

---

## Component Design

### Content Script Components

#### TextFieldMonitor

```typescript
// src/content/TextFieldMonitor.ts

class TextFieldMonitor {
  private fields = new Map<string, TextFieldState>();
  private observer: MutationObserver;
  private checkDebounceMs = 300;

  constructor() {
    this.observer = new MutationObserver(this.handleMutations.bind(this));
  }

  /**
   * Start monitoring the document for text fields
   */
  start(): void {
    // Find existing text fields
    this.scanForTextFields(document.body);

    // Watch for new text fields
    this.observer.observe(document.body, {
      childList: true,
      subtree: true,
    });
  }

  /**
   * Stop monitoring and clean up
   */
  stop(): void {
    this.observer.disconnect();
    this.fields.forEach(field => this.detachField(field));
    this.fields.clear();
  }

  private scanForTextFields(root: Element): void {
    // Find textareas
    root.querySelectorAll('textarea').forEach(el => {
      this.attachTextField(el as HTMLTextAreaElement);
    });

    // Find contenteditable
    root.querySelectorAll('[contenteditable="true"]').forEach(el => {
      this.attachTextField(el as HTMLElement);
    });
  }

  private attachTextField(element: HTMLElement): void {
    const id = this.generateId(element);
    if (this.fields.has(id)) return;

    const state: TextFieldState = {
      id,
      element,
      text: this.getTextContent(element),
      cursorPosition: 0,
      issues: [],
      lastChecked: 0,
      checking: false,
    };

    this.fields.set(id, state);

    // Attach listeners
    element.addEventListener('input', this.handleInput.bind(this, state));
    element.addEventListener('focus', this.handleFocus.bind(this, state));
    element.addEventListener('blur', this.handleBlur.bind(this, state));
  }

  private handleInput = debounce((state: TextFieldState, event: Event): void => {
    state.text = this.getTextContent(state.element);
    this.triggerCheck(state);
  }, this.checkDebounceMs);

  private async triggerCheck(state: TextFieldState): Promise<void> {
    if (state.checking) return;
    state.checking = true;

    try {
      const result = await chrome.runtime.sendMessage({
        type: 'CHECK_TEXT',
        text: state.text,
        language: 'en-US', // TODO: detect or use setting
      });

      this.updateIssues(state, result.issues);
    } finally {
      state.checking = false;
      state.lastChecked = Date.now();
    }
  }
}
```

#### SuggestionRenderer

```typescript
// src/content/SuggestionRenderer.ts

class SuggestionRenderer {
  private shadowHost: HTMLElement;
  private shadowRoot: ShadowRoot;

  constructor() {
    // Create shadow DOM host for style isolation
    this.shadowHost = document.createElement('writeforge-suggestions');
    this.shadowRoot = this.shadowHost.attachShadow({ mode: 'closed' });

    // Inject styles
    const styles = document.createElement('style');
    styles.textContent = SUGGESTION_STYLES;
    this.shadowRoot.appendChild(styles);

    document.body.appendChild(this.shadowHost);
  }

  /**
   * Render underline for an issue
   */
  renderUnderline(issue: RenderedIssue): HTMLElement {
    const rect = issue.range.getBoundingClientRect();

    const underline = document.createElement('div');
    underline.className = `wf-underline wf-underline--${issue.issue.type}`;
    underline.style.cssText = `
      position: fixed;
      left: ${rect.left}px;
      top: ${rect.bottom - 2}px;
      width: ${rect.width}px;
      height: 2px;
      pointer-events: auto;
      z-index: 999999;
    `;

    underline.addEventListener('click', () => this.showCard(issue));

    this.shadowRoot.appendChild(underline);
    return underline;
  }

  /**
   * Show suggestion card for an issue
   */
  showCard(issue: RenderedIssue): void {
    // Remove any existing card
    this.hideAllCards();

    const rect = issue.range.getBoundingClientRect();
    const card = this.createCard(issue);

    // Position below the underline
    card.style.left = `${rect.left}px`;
    card.style.top = `${rect.bottom + 4}px`;

    this.shadowRoot.appendChild(card);
    issue.cardVisible = true;
  }

  private createCard(issue: RenderedIssue): HTMLElement {
    const card = document.createElement('div');
    card.className = 'wf-card';
    card.innerHTML = `
      <div class="wf-card__header">
        <span class="wf-card__type wf-card__type--${issue.issue.type}">
          ${issue.issue.type}
        </span>
      </div>
      <div class="wf-card__content">
        <p class="wf-card__message">${issue.issue.message}</p>
        <div class="wf-card__replacements">
          ${issue.issue.replacements.slice(0, 3).map(r => `
            <button class="wf-card__replacement" data-replacement="${r}">
              ${r}
            </button>
          `).join('')}
        </div>
      </div>
      <div class="wf-card__actions">
        <button class="wf-btn wf-btn--dismiss">Dismiss</button>
        <button class="wf-btn wf-btn--ignore">Ignore rule</button>
      </div>
    `;

    // Attach event handlers
    card.querySelectorAll('.wf-card__replacement').forEach(btn => {
      btn.addEventListener('click', () => {
        this.acceptReplacement(issue, btn.dataset.replacement!);
      });
    });

    card.querySelector('.wf-btn--dismiss')?.addEventListener('click', () => {
      this.dismiss(issue);
    });

    card.querySelector('.wf-btn--ignore')?.addEventListener('click', () => {
      this.ignoreRule(issue);
    });

    return card;
  }

  private acceptReplacement(issue: RenderedIssue, replacement: string): void {
    // Apply the replacement to the text
    const { element } = issue.range.startContainer.parentElement!
      .closest('[contenteditable], textarea') as any;

    // For textarea
    if (element instanceof HTMLTextAreaElement) {
      const start = issue.issue.offset;
      const end = start + issue.issue.length;
      element.value =
        element.value.slice(0, start) +
        replacement +
        element.value.slice(end);
      element.dispatchEvent(new Event('input', { bubbles: true }));
    }

    // For contenteditable
    else {
      issue.range.deleteContents();
      issue.range.insertNode(document.createTextNode(replacement));
    }

    issue.status = 'accepted';
    this.removeIssue(issue);
  }
}
```

### Background Worker

```typescript
// src/background/index.ts

import { GrammarService, LanguageToolClient } from '@writeforge/core-grammar';
import { LLMService } from '@writeforge/core-llm';
import { DictionaryService } from './DictionaryService';

const grammarClient = new LanguageToolClient({
  baseUrl: 'http://localhost:8010',
});
const grammarService = new GrammarService(grammarClient);

let llmService: LLMService | null = null;

// Initialize LLM lazily (large model download)
async function initLLM(): Promise<LLMService> {
  if (!llmService) {
    llmService = new LLMService();
    await llmService.loadModel('Qwen2.5-0.5B-Instruct-q4f16_1-MLC');
  }
  return llmService;
}

const dictionaryService = new DictionaryService();

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  handleMessage(message).then(sendResponse);
  return true; // Keep channel open for async response
});

async function handleMessage(message: ExtensionMessage): Promise<unknown> {
  switch (message.type) {
    case 'CHECK_TEXT': {
      const result = await grammarService.check(message.text, {
        language: message.language,
        dictionary: await dictionaryService.getWords(),
      });
      return result;
    }

    case 'GET_AI_SUGGESTION': {
      const llm = await initLLM();
      const suggestion = await llm.getSuggestion(message.text, message.context);
      return suggestion;
    }

    case 'ADD_TO_DICTIONARY': {
      await dictionaryService.addWord(message.word);
      return { success: true };
    }

    case 'REMOVE_FROM_DICTIONARY': {
      await dictionaryService.removeWord(message.word);
      return { success: true };
    }

    case 'GET_SETTINGS': {
      return chrome.storage.local.get('settings');
    }

    case 'UPDATE_SETTINGS': {
      await chrome.storage.local.set({
        settings: { ...(await chrome.storage.local.get('settings')).settings, ...message.settings },
      });
      return { success: true };
    }

    default:
      throw new Error(`Unknown message type: ${(message as any).type}`);
  }
}
```

---

## Site-Specific Integrations

### Google Docs (F1.2.3)

Google Docs uses Canvas for rendering, requiring special handling:

```typescript
// src/content/integrations/GoogleDocs.ts

class GoogleDocsIntegration {
  private editorElement: HTMLElement | null = null;

  detect(): boolean {
    return window.location.hostname === 'docs.google.com';
  }

  initialize(): void {
    // Google Docs uses an iframe with class 'docs-texteventtarget-iframe'
    this.waitForEditor().then(editor => {
      this.editorElement = editor;
      this.attachListeners();
    });
  }

  private async waitForEditor(): Promise<HTMLElement> {
    return new Promise(resolve => {
      const check = () => {
        const editor = document.querySelector('.kix-appview-editor');
        if (editor) {
          resolve(editor as HTMLElement);
        } else {
          setTimeout(check, 500);
        }
      };
      check();
    });
  }

  private attachListeners(): void {
    // Listen for keyboard input to detect changes
    document.addEventListener('keydown', this.handleKeyDown.bind(this), true);

    // Use Accessibility API to get text content
    // Google Docs exposes content via ARIA
    this.observeAriaChanges();
  }

  private observeAriaChanges(): void {
    const observer = new MutationObserver(mutations => {
      // Look for changes in aria-label attributes which contain text
      const textChanges = mutations.filter(m =>
        m.type === 'attributes' && m.attributeName === 'aria-label'
      );

      if (textChanges.length > 0) {
        this.extractAndCheckText();
      }
    });

    observer.observe(this.editorElement!, {
      attributes: true,
      subtree: true,
      attributeFilter: ['aria-label'],
    });
  }

  private extractAndCheckText(): void {
    // Extract text from Google Docs using selection
    // This is complex due to Canvas rendering
    // Alternative: Use Google Docs API if available

    const textContent = this.getVisibleText();
    // Trigger grammar check...
  }

  private getVisibleText(): string {
    // Google Docs stores text in elements with class 'kix-lineview'
    const lines = document.querySelectorAll('.kix-lineview');
    return Array.from(lines)
      .map(line => line.textContent || '')
      .join('\n');
  }
}
```

### Gmail Compose (F1.2.4)

```typescript
// src/content/integrations/Gmail.ts

class GmailIntegration {
  detect(): boolean {
    return window.location.hostname === 'mail.google.com';
  }

  initialize(): void {
    // Wait for compose window to open
    this.observeComposeWindows();
  }

  private observeComposeWindows(): void {
    const observer = new MutationObserver(mutations => {
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node instanceof HTMLElement) {
            // Gmail compose body has role="textbox"
            const composeBody = node.querySelector('[role="textbox"][aria-label*="Message Body"]');
            if (composeBody) {
              this.attachToCompose(composeBody as HTMLElement);
            }
          }
        });
      });
    });

    observer.observe(document.body, { childList: true, subtree: true });
  }

  private attachToCompose(element: HTMLElement): void {
    // Gmail compose is contenteditable
    // Standard contenteditable handling works here
    element.addEventListener('input', debounce(() => {
      this.checkText(element.textContent || '');
    }, 300));
  }
}
```

---

## UI Components (Preact)

### Popup Component

```tsx
// src/popup/Popup.tsx

import { h, FunctionComponent } from 'preact';
import { useState, useEffect } from 'preact/hooks';

interface PopupState {
  enabled: boolean;
  issueCount: number;
  language: string;
  ltServerStatus: 'connected' | 'disconnected' | 'checking';
}

export const Popup: FunctionComponent = () => {
  const [state, setState] = useState<PopupState>({
    enabled: true,
    issueCount: 0,
    language: 'en-US',
    ltServerStatus: 'checking',
  });

  useEffect(() => {
    // Check LanguageTool server status
    checkServerStatus();
    // Get current tab's issue count
    getCurrentTabIssues();
  }, []);

  const checkServerStatus = async () => {
    try {
      const response = await fetch('http://localhost:8010/v2/languages');
      setState(s => ({ ...s, ltServerStatus: response.ok ? 'connected' : 'disconnected' }));
    } catch {
      setState(s => ({ ...s, ltServerStatus: 'disconnected' }));
    }
  };

  const toggleEnabled = async () => {
    const newEnabled = !state.enabled;
    setState(s => ({ ...s, enabled: newEnabled }));
    await chrome.runtime.sendMessage({
      type: 'UPDATE_SETTINGS',
      settings: { enabled: newEnabled },
    });
  };

  return (
    <div class="wf-popup">
      <header class="wf-popup__header">
        <img src="/icons/icon-48.png" alt="WriteForge" class="wf-popup__logo" />
        <h1 class="wf-popup__title">WriteForge</h1>
      </header>

      <div class="wf-popup__status">
        <div class={`wf-status-indicator wf-status-indicator--${state.ltServerStatus}`} />
        <span>
          {state.ltServerStatus === 'connected' && 'Grammar checking active'}
          {state.ltServerStatus === 'disconnected' && 'Server not running'}
          {state.ltServerStatus === 'checking' && 'Connecting...'}
        </span>
      </div>

      {state.issueCount > 0 && (
        <div class="wf-popup__issues">
          <span class="wf-issue-count">{state.issueCount}</span>
          <span>issues found on this page</span>
        </div>
      )}

      <div class="wf-popup__controls">
        <label class="wf-toggle">
          <input
            type="checkbox"
            checked={state.enabled}
            onChange={toggleEnabled}
          />
          <span class="wf-toggle__slider" />
          <span class="wf-toggle__label">Enable checking</span>
        </label>
      </div>

      <footer class="wf-popup__footer">
        <a href="#" onClick={() => chrome.runtime.openOptionsPage()}>
          Settings
        </a>
        <span class="wf-popup__version">v0.1.0</span>
      </footer>
    </div>
  );
};
```

---

## File Structure

```
packages/extension/
├── src/
│   ├── background/
│   │   ├── index.ts              # Service worker entry
│   │   ├── DictionaryService.ts  # Personal dictionary
│   │   └── handlers/
│   │       ├── grammar.ts
│   │       └── llm.ts
│   ├── content/
│   │   ├── index.ts              # Content script entry
│   │   ├── TextFieldMonitor.ts   # Text field detection
│   │   ├── SuggestionRenderer.ts # Visual rendering
│   │   ├── integrations/
│   │   │   ├── index.ts
│   │   │   ├── GoogleDocs.ts
│   │   │   └── Gmail.ts
│   │   └── styles/
│   │       └── suggestions.css
│   ├── popup/
│   │   ├── index.tsx             # Popup entry
│   │   ├── Popup.tsx             # Main popup component
│   │   └── popup.css
│   ├── options/
│   │   ├── index.tsx             # Options page entry
│   │   ├── Options.tsx           # Options component
│   │   └── options.css
│   ├── lib/
│   │   ├── utils.ts
│   │   ├── logger.ts
│   │   └── storage.ts
│   └── types/
│       └── index.ts
├── public/
│   ├── icons/
│   │   ├── icon-16.png
│   │   ├── icon-32.png
│   │   ├── icon-48.png
│   │   └── icon-128.png
│   └── _locales/
│       └── en/
│           └── messages.json
├── wxt.config.ts
├── package.json
├── tsconfig.json
└── README.md
```

---

## WXT Configuration

```typescript
// wxt.config.ts

import { defineConfig } from 'wxt';

export default defineConfig({
  srcDir: 'src',
  manifest: {
    name: 'WriteForge',
    description: 'Privacy-first AI writing assistant. 100% local processing.',
    permissions: ['storage', 'activeTab'],
    host_permissions: ['http://localhost:8010/*'],
  },
  modules: ['@wxt-dev/module-preact'],
});
```

---

## Testing Strategy

### Unit Tests

```typescript
describe('TextFieldMonitor', () => {
  it('should detect textarea elements', () => {
    document.body.innerHTML = '<textarea id="test"></textarea>';
    const monitor = new TextFieldMonitor();
    monitor.start();

    expect(monitor.getFields()).toHaveLength(1);
  });

  it('should trigger check on input', async () => {
    const checkSpy = vi.spyOn(chrome.runtime, 'sendMessage');
    document.body.innerHTML = '<textarea id="test"></textarea>';

    const monitor = new TextFieldMonitor();
    monitor.start();

    const textarea = document.querySelector('textarea')!;
    textarea.value = 'This are a test';
    textarea.dispatchEvent(new Event('input', { bubbles: true }));

    await vi.waitFor(() => {
      expect(checkSpy).toHaveBeenCalledWith({
        type: 'CHECK_TEXT',
        text: 'This are a test',
        language: 'en-US',
      });
    });
  });
});
```

### E2E Tests (Playwright)

```typescript
// e2e/extension.spec.ts

import { test, expect, chromium } from '@playwright/test';

test.describe('WriteForge Extension', () => {
  test('should underline grammar errors in textarea', async () => {
    const browser = await chromium.launchPersistentContext('', {
      headless: false,
      args: [
        `--disable-extensions-except=${extensionPath}`,
        `--load-extension=${extensionPath}`,
      ],
    });

    const page = await browser.newPage();
    await page.goto('about:blank');

    // Add textarea
    await page.setContent('<textarea id="test" style="width:400px;height:100px"></textarea>');

    // Type text with error
    await page.fill('#test', 'This are a test.');

    // Wait for underline to appear
    await expect(page.locator('.wf-underline')).toBeVisible({ timeout: 2000 });

    // Click underline to show card
    await page.click('.wf-underline');

    // Verify suggestion card appears
    await expect(page.locator('.wf-card')).toBeVisible();
    await expect(page.locator('.wf-card')).toContainText('is');

    await browser.close();
  });
});
```

---

## Performance Targets

| Metric | Target | Measurement |
|--------|--------|-------------|
| Content script load | <50ms | Performance API |
| Text field detection | <10ms | Initial scan |
| Underline rendering | <16ms | Per issue (60fps) |
| Suggestion card show | <50ms | Click to visible |
| Memory (idle) | <20MB | Chrome task manager |
| Memory (active) | <50MB | During checking |

---

## Acceptance Criteria

- [ ] Extension loads without errors on Chrome 120+
- [ ] Textareas detected and monitored automatically
- [ ] Contenteditable elements detected and monitored
- [ ] Google Docs integration working (text extraction)
- [ ] Gmail compose integration working
- [ ] Underlines rendered with correct colors by type
- [ ] Suggestion cards appear on underline click
- [ ] Accept button applies replacement
- [ ] Dismiss button hides the issue
- [ ] Works 100% offline when LT server is local
- [ ] Popup shows server status and issue count
- [ ] Options page allows language and site configuration
- [ ] 80% test coverage
- [ ] <100ms grammar check latency

---

**Document Version:** 1.0.0
**Created:** January 2026
**Author:** AI Assistant
