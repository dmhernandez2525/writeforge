# F1.5: Personal Dictionary

**Feature ID:** F1.5
**Priority:** P0 (MVP)
**Status:** Not Started
**Packages:** `@writeforge/core-dictionary`, extensions, desktop apps

---

## Overview

Implement a personal dictionary system allowing users to add custom words (names, technical terms, abbreviations) that should not be flagged as spelling errors. The dictionary is stored locally and can be exported/imported for manual sync between platforms.

### Goals

1. Add words to dictionary via right-click or keyboard shortcut
2. Remove words from dictionary
3. Dictionary management UI in settings
4. Export/import dictionary as JSON
5. Technical terminology presets (programming, medical, legal)
6. Dictionary shared with LanguageTool during checks

### Non-Goals

- Cloud sync (P1 - F2.15)
- Shared team dictionaries (P2 - F3.8)
- Auto-learning from user corrections (P2)

---

## Architecture

```
┌──────────────────────────────────────────────────────────────────┐
│                   @writeforge/core-dictionary                     │
├──────────────────────────────────────────────────────────────────┤
│                                                                    │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │                    DictionaryService                         │  │
│  │  - addWord(word)                                            │  │
│  │  - removeWord(word)                                         │  │
│  │  - hasWord(word): boolean                                   │  │
│  │  - getWords(): string[]                                     │  │
│  │  - import(data)                                             │  │
│  │  - export(): DictionaryExport                               │  │
│  └──────────────────────────┬──────────────────────────────────┘  │
│                             │                                      │
│  ┌──────────────────────────┴──────────────────────────────────┐  │
│  │                    StorageAdapter                            │  │
│  │  (Abstract - platform-specific implementations)              │  │
│  └──────────────────────────┬──────────────────────────────────┘  │
│                             │                                      │
│           ┌─────────────────┼─────────────────┐                   │
│           ▼                 ▼                 ▼                   │
│  ┌─────────────────┐ ┌─────────────┐ ┌─────────────────┐         │
│  │ ChromeStorage   │ │ SQLiteStore │ │ FileSystemStore │         │
│  │ (Extension)     │ │ (Desktop)   │ │ (Fallback)      │         │
│  └─────────────────┘ └─────────────┘ └─────────────────┘         │
│                                                                    │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │                    Preset Manager                            │  │
│  │  - Programming terms                                        │  │
│  │  - Medical terms                                            │  │
│  │  - Legal terms                                              │  │
│  │  - Custom presets                                           │  │
│  └─────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────┘
```

---

## Data Models

### DictionaryEntry

```typescript
interface DictionaryEntry {
  /** The word itself (normalized to lowercase for matching) */
  word: string;

  /** Original casing as user entered it */
  originalCase: string;

  /** When the word was added */
  addedAt: number;

  /** Source of the word */
  source: 'user' | 'preset' | 'import';

  /** Preset name if from preset */
  presetId?: string;

  /** Optional category for organization */
  category?: string;
}
```

### Dictionary

```typescript
interface Dictionary {
  /** Schema version for migrations */
  version: number;

  /** All dictionary entries */
  entries: DictionaryEntry[];

  /** Enabled preset IDs */
  enabledPresets: string[];

  /** Last modified timestamp */
  lastModified: number;
}
```

### DictionaryExport

```typescript
interface DictionaryExport {
  /** Export format version */
  formatVersion: 1;

  /** Export timestamp */
  exportedAt: string;

  /** Application version that created export */
  appVersion: string;

  /** User-added words only */
  words: string[];

  /** Enabled presets */
  presets: string[];

  /** Optional metadata */
  metadata?: {
    deviceName?: string;
    platform?: string;
  };
}
```

### Preset

```typescript
interface Preset {
  /** Unique preset identifier */
  id: string;

  /** Display name */
  name: string;

  /** Description */
  description: string;

  /** Category for grouping */
  category: 'technical' | 'professional' | 'academic' | 'custom';

  /** Words in this preset */
  words: string[];

  /** Whether preset is built-in or user-created */
  builtIn: boolean;
}
```

---

## API Design

### DictionaryService

```typescript
class DictionaryService {
  private storage: StorageAdapter;
  private dictionary: Dictionary;
  private presetManager: PresetManager;

  constructor(storage: StorageAdapter) {
    this.storage = storage;
    this.presetManager = new PresetManager();
  }

  /**
   * Initialize service and load dictionary
   */
  async initialize(): Promise<void> {
    this.dictionary = await this.storage.load();
  }

  /**
   * Add a word to the dictionary
   */
  async addWord(word: string, options?: AddWordOptions): Promise<void> {
    const normalized = word.toLowerCase().trim();

    if (this.hasWord(normalized)) {
      return; // Already exists
    }

    const entry: DictionaryEntry = {
      word: normalized,
      originalCase: word.trim(),
      addedAt: Date.now(),
      source: options?.source ?? 'user',
      category: options?.category,
    };

    this.dictionary.entries.push(entry);
    this.dictionary.lastModified = Date.now();

    await this.storage.save(this.dictionary);
    this.emit('wordAdded', entry);
  }

  /**
   * Remove a word from the dictionary
   */
  async removeWord(word: string): Promise<boolean> {
    const normalized = word.toLowerCase().trim();
    const index = this.dictionary.entries.findIndex(e => e.word === normalized);

    if (index === -1) {
      return false;
    }

    const removed = this.dictionary.entries.splice(index, 1)[0];
    this.dictionary.lastModified = Date.now();

    await this.storage.save(this.dictionary);
    this.emit('wordRemoved', removed);

    return true;
  }

  /**
   * Check if word exists in dictionary (including presets)
   */
  hasWord(word: string): boolean {
    const normalized = word.toLowerCase().trim();

    // Check user dictionary
    if (this.dictionary.entries.some(e => e.word === normalized)) {
      return true;
    }

    // Check enabled presets
    return this.presetManager.hasWord(normalized, this.dictionary.enabledPresets);
  }

  /**
   * Get all words (user + enabled presets)
   */
  getWords(): string[] {
    const userWords = this.dictionary.entries.map(e => e.word);
    const presetWords = this.presetManager.getWords(this.dictionary.enabledPresets);

    return [...new Set([...userWords, ...presetWords])];
  }

  /**
   * Get user-added words only
   */
  getUserWords(): DictionaryEntry[] {
    return this.dictionary.entries.filter(e => e.source === 'user');
  }

  /**
   * Enable a preset
   */
  async enablePreset(presetId: string): Promise<void> {
    if (!this.dictionary.enabledPresets.includes(presetId)) {
      this.dictionary.enabledPresets.push(presetId);
      this.dictionary.lastModified = Date.now();
      await this.storage.save(this.dictionary);
      this.emit('presetEnabled', presetId);
    }
  }

  /**
   * Disable a preset
   */
  async disablePreset(presetId: string): Promise<void> {
    const index = this.dictionary.enabledPresets.indexOf(presetId);
    if (index !== -1) {
      this.dictionary.enabledPresets.splice(index, 1);
      this.dictionary.lastModified = Date.now();
      await this.storage.save(this.dictionary);
      this.emit('presetDisabled', presetId);
    }
  }

  /**
   * Export dictionary for backup/transfer
   */
  export(): DictionaryExport {
    return {
      formatVersion: 1,
      exportedAt: new Date().toISOString(),
      appVersion: VERSION,
      words: this.getUserWords().map(e => e.originalCase),
      presets: this.dictionary.enabledPresets,
    };
  }

  /**
   * Import dictionary from export file
   */
  async import(data: DictionaryExport, options?: ImportOptions): Promise<ImportResult> {
    const { merge = true } = options ?? {};

    if (!merge) {
      // Replace mode: clear existing
      this.dictionary.entries = [];
    }

    let added = 0;
    let skipped = 0;

    for (const word of data.words) {
      if (this.hasWord(word)) {
        skipped++;
      } else {
        await this.addWord(word, { source: 'import' });
        added++;
      }
    }

    // Update presets
    for (const presetId of data.presets) {
      await this.enablePreset(presetId);
    }

    return { added, skipped, presets: data.presets.length };
  }

  /**
   * Search words matching pattern
   */
  search(pattern: string): DictionaryEntry[] {
    const normalized = pattern.toLowerCase();
    return this.dictionary.entries.filter(e =>
      e.word.includes(normalized) || e.originalCase.includes(pattern)
    );
  }
}
```

### PresetManager

```typescript
class PresetManager {
  private presets: Map<string, Preset>;

  constructor() {
    this.presets = new Map();
    this.loadBuiltInPresets();
  }

  private loadBuiltInPresets(): void {
    // Programming terms
    this.presets.set('programming', {
      id: 'programming',
      name: 'Programming',
      description: 'Common programming terms, languages, and frameworks',
      category: 'technical',
      builtIn: true,
      words: [
        'api', 'json', 'xml', 'html', 'css', 'javascript', 'typescript',
        'python', 'golang', 'rust', 'kotlin', 'swift', 'npm', 'pnpm',
        'webpack', 'vite', 'eslint', 'prettier', 'dockerfile', 'kubernetes',
        'redis', 'mongodb', 'postgresql', 'graphql', 'restful', 'oauth',
        'jwt', 'async', 'await', 'callback', 'middleware', 'frontend',
        'backend', 'fullstack', 'devops', 'cicd', 'github', 'gitlab',
        // ... many more
      ],
    });

    // Tech company/product names
    this.presets.set('tech-companies', {
      id: 'tech-companies',
      name: 'Tech Companies & Products',
      description: 'Technology companies, products, and services',
      category: 'technical',
      builtIn: true,
      words: [
        'google', 'microsoft', 'apple', 'amazon', 'netflix', 'spotify',
        'openai', 'anthropic', 'vercel', 'cloudflare', 'datadog',
        'macbook', 'iphone', 'android', 'ios', 'linux', 'ubuntu',
        // ... many more
      ],
    });

    // Medical terms (simplified example)
    this.presets.set('medical', {
      id: 'medical',
      name: 'Medical Terminology',
      description: 'Common medical terms and abbreviations',
      category: 'professional',
      builtIn: true,
      words: [
        'hypertension', 'cardiovascular', 'oncology', 'hematology',
        'neurological', 'orthopedic', 'pediatric', 'geriatric',
        // ... many more
      ],
    });

    // Legal terms
    this.presets.set('legal', {
      id: 'legal',
      name: 'Legal Terminology',
      description: 'Common legal terms and Latin phrases',
      category: 'professional',
      builtIn: true,
      words: [
        'plaintiff', 'defendant', 'affidavit', 'subpoena', 'deposition',
        'amicus', 'curiae', 'habeas', 'corpus', 'mandamus',
        // ... many more
      ],
    });
  }

  getPresets(): Preset[] {
    return Array.from(this.presets.values());
  }

  getPreset(id: string): Preset | undefined {
    return this.presets.get(id);
  }

  hasWord(word: string, enabledPresets: string[]): boolean {
    for (const presetId of enabledPresets) {
      const preset = this.presets.get(presetId);
      if (preset?.words.includes(word)) {
        return true;
      }
    }
    return false;
  }

  getWords(enabledPresets: string[]): string[] {
    const words: string[] = [];
    for (const presetId of enabledPresets) {
      const preset = this.presets.get(presetId);
      if (preset) {
        words.push(...preset.words);
      }
    }
    return words;
  }
}
```

---

## Storage Adapters

### Chrome Extension Storage

```typescript
// src/storage/ChromeStorageAdapter.ts

export class ChromeStorageAdapter implements StorageAdapter {
  private readonly key = 'writeforge_dictionary';

  async load(): Promise<Dictionary> {
    const result = await chrome.storage.local.get(this.key);
    return result[this.key] ?? this.createEmpty();
  }

  async save(dictionary: Dictionary): Promise<void> {
    await chrome.storage.local.set({ [this.key]: dictionary });
  }

  private createEmpty(): Dictionary {
    return {
      version: 1,
      entries: [],
      enabledPresets: ['programming'], // Enable programming by default
      lastModified: Date.now(),
    };
  }
}
```

### SQLite Storage (Desktop)

```swift
// packages/desktop-mac/WriteForge/Services/DictionaryStorage.swift

import SQLite
import Foundation

final class DictionaryStorage {
    private let db: Connection
    private let words = Table("words")
    private let id = Expression<Int64>("id")
    private let word = Expression<String>("word")
    private let originalCase = Expression<String>("original_case")
    private let addedAt = Expression<Int64>("added_at")
    private let source = Expression<String>("source")
    private let category = Expression<String?>("category")

    init() throws {
        let path = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask)
            .first!
            .appendingPathComponent("WriteForge")
            .appendingPathComponent("dictionary.sqlite")

        // Ensure directory exists
        try FileManager.default.createDirectory(
            at: path.deletingLastPathComponent(),
            withIntermediateDirectories: true
        )

        db = try Connection(path.path)
        try createTables()
    }

    private func createTables() throws {
        try db.run(words.create(ifNotExists: true) { t in
            t.column(id, primaryKey: .autoincrement)
            t.column(word, unique: true)
            t.column(originalCase)
            t.column(addedAt)
            t.column(source)
            t.column(category)
        })

        try db.run(words.createIndex(word, ifNotExists: true))
    }

    func addWord(_ entry: DictionaryEntry) throws {
        let insert = words.insert(
            word <- entry.word,
            originalCase <- entry.originalCase,
            addedAt <- Int64(entry.addedAt),
            source <- entry.source.rawValue,
            category <- entry.category
        )
        try db.run(insert)
    }

    func removeWord(_ wordToRemove: String) throws -> Bool {
        let query = words.filter(word == wordToRemove.lowercased())
        let count = try db.run(query.delete())
        return count > 0
    }

    func hasWord(_ wordToCheck: String) -> Bool {
        let query = words.filter(word == wordToCheck.lowercased())
        return (try? db.pluck(query)) != nil
    }

    func getAllWords() throws -> [DictionaryEntry] {
        try db.prepare(words).map { row in
            DictionaryEntry(
                word: row[word],
                originalCase: row[originalCase],
                addedAt: UInt64(row[addedAt]),
                source: Source(rawValue: row[source]) ?? .user,
                category: row[category]
            )
        }
    }
}
```

---

## UI Components

### Right-Click Context Menu (Extension)

```typescript
// src/content/ContextMenu.ts

export function setupContextMenu(): void {
  // Create context menu item
  chrome.contextMenus.create({
    id: 'add-to-dictionary',
    title: 'Add "%s" to WriteForge Dictionary',
    contexts: ['selection'],
  });

  // Handle click
  chrome.contextMenus.onClicked.addListener((info, tab) => {
    if (info.menuItemId === 'add-to-dictionary' && info.selectionText) {
      chrome.runtime.sendMessage({
        type: 'ADD_TO_DICTIONARY',
        word: info.selectionText.trim(),
      });

      // Show confirmation
      chrome.scripting.executeScript({
        target: { tabId: tab!.id! },
        func: showAddedNotification,
        args: [info.selectionText.trim()],
      });
    }
  });
}

function showAddedNotification(word: string): void {
  const notification = document.createElement('div');
  notification.className = 'wf-notification';
  notification.textContent = `"${word}" added to dictionary`;
  document.body.appendChild(notification);

  setTimeout(() => notification.remove(), 2000);
}
```

### Dictionary Management UI (Options Page)

```tsx
// src/options/DictionaryManager.tsx

import { h, FunctionComponent } from 'preact';
import { useState, useEffect } from 'preact/hooks';

interface DictionaryManagerProps {
  service: DictionaryService;
}

export const DictionaryManager: FunctionComponent<DictionaryManagerProps> = ({
  service,
}) => {
  const [words, setWords] = useState<DictionaryEntry[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [newWord, setNewWord] = useState('');
  const [presets, setPresets] = useState<Preset[]>([]);

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    setWords(service.getUserWords());
    setPresets(service.getAvailablePresets());
  };

  const handleAdd = async () => {
    if (newWord.trim()) {
      await service.addWord(newWord);
      setNewWord('');
      loadData();
    }
  };

  const handleRemove = async (word: string) => {
    await service.removeWord(word);
    loadData();
  };

  const handleExport = () => {
    const data = service.export();
    const blob = new Blob([JSON.stringify(data, null, 2)], {
      type: 'application/json',
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `writeforge-dictionary-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const handleImport = async (file: File) => {
    const text = await file.text();
    const data = JSON.parse(text) as DictionaryExport;
    const result = await service.import(data, { merge: true });
    alert(`Imported ${result.added} words (${result.skipped} already existed)`);
    loadData();
  };

  const filteredWords = searchQuery
    ? words.filter(w =>
        w.word.includes(searchQuery.toLowerCase()) ||
        w.originalCase.includes(searchQuery)
      )
    : words;

  return (
    <div class="wf-dictionary-manager">
      <section class="wf-section">
        <h2>Personal Dictionary</h2>
        <p class="wf-description">
          Words you add here won't be flagged as spelling errors.
        </p>

        <div class="wf-add-word">
          <input
            type="text"
            value={newWord}
            onInput={e => setNewWord((e.target as HTMLInputElement).value)}
            placeholder="Add a word..."
            onKeyDown={e => e.key === 'Enter' && handleAdd()}
          />
          <button onClick={handleAdd}>Add</button>
        </div>

        <div class="wf-search">
          <input
            type="search"
            value={searchQuery}
            onInput={e => setSearchQuery((e.target as HTMLInputElement).value)}
            placeholder="Search words..."
          />
        </div>

        <div class="wf-word-list">
          {filteredWords.map(entry => (
            <div key={entry.word} class="wf-word-item">
              <span class="wf-word">{entry.originalCase}</span>
              <span class="wf-word-meta">
                Added {new Date(entry.addedAt).toLocaleDateString()}
              </span>
              <button
                class="wf-btn-remove"
                onClick={() => handleRemove(entry.word)}
                aria-label={`Remove ${entry.word}`}
              >
                ×
              </button>
            </div>
          ))}

          {filteredWords.length === 0 && (
            <p class="wf-empty">
              {searchQuery ? 'No words match your search' : 'No words added yet'}
            </p>
          )}
        </div>

        <div class="wf-actions">
          <button onClick={handleExport}>Export Dictionary</button>
          <label class="wf-btn-import">
            Import Dictionary
            <input
              type="file"
              accept=".json"
              onChange={e => {
                const file = (e.target as HTMLInputElement).files?.[0];
                if (file) handleImport(file);
              }}
            />
          </label>
        </div>
      </section>

      <section class="wf-section">
        <h2>Terminology Presets</h2>
        <p class="wf-description">
          Enable presets to automatically include common terms.
        </p>

        <div class="wf-preset-list">
          {presets.map(preset => (
            <label key={preset.id} class="wf-preset-item">
              <input
                type="checkbox"
                checked={service.isPresetEnabled(preset.id)}
                onChange={e =>
                  (e.target as HTMLInputElement).checked
                    ? service.enablePreset(preset.id)
                    : service.disablePreset(preset.id)
                }
              />
              <div class="wf-preset-info">
                <span class="wf-preset-name">{preset.name}</span>
                <span class="wf-preset-description">{preset.description}</span>
                <span class="wf-preset-count">{preset.words.length} words</span>
              </div>
            </label>
          ))}
        </div>
      </section>
    </div>
  );
};
```

---

## Integration with Grammar Checking

```typescript
// In GrammarService

async check(text: string, options?: CheckOptions): Promise<GrammarCheck> {
  const dictionary = await this.dictionaryService.getWords();

  // Pass dictionary to LanguageTool API
  const ltOptions = {
    ...options,
    // LanguageTool doesn't have a dictionary param, so we use disabled rules
    // for words. Alternative: filter results post-hoc.
  };

  const result = await this.ltClient.check(text, ltOptions);

  // Filter out issues for dictionary words
  const filteredIssues = result.issues.filter(issue => {
    // If it's a spelling error and the word is in dictionary, skip it
    if (issue.type === 'spelling') {
      const problemWord = text.slice(issue.offset, issue.offset + issue.length);
      if (this.dictionaryService.hasWord(problemWord)) {
        return false;
      }
    }
    return true;
  });

  return { ...result, issues: filteredIssues };
}
```

---

## File Structure

```
packages/core/dictionary/
├── src/
│   ├── index.ts                  # Public exports
│   ├── DictionaryService.ts      # Main service
│   ├── PresetManager.ts          # Built-in presets
│   ├── storage/
│   │   ├── StorageAdapter.ts     # Abstract interface
│   │   ├── ChromeStorage.ts      # Extension storage
│   │   └── FileStorage.ts        # Fallback file storage
│   ├── presets/
│   │   ├── programming.json
│   │   ├── medical.json
│   │   ├── legal.json
│   │   └── tech-companies.json
│   ├── types.ts
│   └── __tests__/
│       ├── DictionaryService.test.ts
│       └── PresetManager.test.ts
├── package.json
├── tsconfig.json
└── README.md
```

---

## Testing Strategy

```typescript
describe('DictionaryService', () => {
  let service: DictionaryService;
  let storage: MockStorageAdapter;

  beforeEach(async () => {
    storage = new MockStorageAdapter();
    service = new DictionaryService(storage);
    await service.initialize();
  });

  describe('addWord', () => {
    it('should add word to dictionary', async () => {
      await service.addWord('TestWord');

      expect(service.hasWord('testword')).toBe(true);
      expect(service.hasWord('TESTWORD')).toBe(true); // Case insensitive
    });

    it('should preserve original casing', async () => {
      await service.addWord('iPhone');

      const words = service.getUserWords();
      expect(words[0].originalCase).toBe('iPhone');
    });

    it('should not duplicate words', async () => {
      await service.addWord('test');
      await service.addWord('TEST');
      await service.addWord('Test');

      expect(service.getUserWords()).toHaveLength(1);
    });
  });

  describe('presets', () => {
    it('should include preset words when enabled', async () => {
      await service.enablePreset('programming');

      expect(service.hasWord('javascript')).toBe(true);
      expect(service.hasWord('typescript')).toBe(true);
    });

    it('should exclude preset words when disabled', async () => {
      await service.enablePreset('programming');
      await service.disablePreset('programming');

      expect(service.hasWord('javascript')).toBe(false);
    });
  });

  describe('export/import', () => {
    it('should export user words', async () => {
      await service.addWord('custom1');
      await service.addWord('custom2');

      const exported = service.export();

      expect(exported.words).toContain('custom1');
      expect(exported.words).toContain('custom2');
    });

    it('should import and merge words', async () => {
      await service.addWord('existing');

      const importData: DictionaryExport = {
        formatVersion: 1,
        exportedAt: new Date().toISOString(),
        appVersion: '1.0.0',
        words: ['existing', 'newword'],
        presets: [],
      };

      const result = await service.import(importData, { merge: true });

      expect(result.added).toBe(1);
      expect(result.skipped).toBe(1);
      expect(service.hasWord('newword')).toBe(true);
    });
  });
});
```

---

## Acceptance Criteria

- [ ] Add word via right-click context menu
- [ ] Add word via keyboard shortcut (Cmd/Ctrl + D on issue)
- [ ] Remove word from dictionary management UI
- [ ] Search words in dictionary
- [ ] Export dictionary to JSON file
- [ ] Import dictionary from JSON file (merge mode)
- [ ] Import dictionary from JSON file (replace mode)
- [ ] Enable/disable presets
- [ ] Programming preset available by default
- [ ] Dictionary words not flagged by grammar checker
- [ ] Dictionary persists across sessions
- [ ] 85% test coverage

---

**Document Version:** 1.0.0
**Created:** January 2026
**Author:** AI Assistant
